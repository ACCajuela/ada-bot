import os
import re
from dotenv import load_dotenv
import discord
from discord.ext import commands, tasks
from discord.ext.commands import MemberConverter, RoleConverter
import aiosqlite
import datetime
import pytz
from reportlab.lib.pagesizes import letter, A4
from reportlab.pdfgen import canvas
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.units import inch
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from database import (
    init_db, connect_db, add_task, get_tasks, update_task_start_date,
    delete_clockpoint_by_id, update_task_status,
    add_meeting_check_in, get_active_meeting_by_user, update_meeting_check_out,
    add_meeting_topic, get_all_meetings, get_meetings_by_user, get_tasks_filtered,
    delete_task, is_user_checked_in, add_check_in, add_check_out, get_clockpoint_entries_by_user,
    get_clockpoint_entries, get_clockpoint_entry_by_id, update_check_in_time, update_task_overdue,
    update_check_out_time, delete_meeting_by_id
)

load_dotenv()

TOKEN = os.getenv("DISCORD_TOKEN")
BR_TZ = pytz.timezone("America/Sao_Paulo")

OVERDUE_INTERVAL = 24 * 60 * 60

TIME_UNITS = {
    'semana': 7 * 24 * 60 * 60,
    'semanas': 7 * 24 * 60 * 60,
    'mes': 30 * 24 * 60 * 60,
    'meses': 30 * 24 * 60 * 60,
    'dia': 24 * 60 * 60,
    'dias': 24 * 60 * 60,
    'hora': 60 * 60,
    'horas': 60 * 60,
    'minuto': 60,
    'minutos': 60,
}

COMMAND_ORDER = [
    'ajuda',
    'add_tarefa',
    'list_tarefas',
    'update_status',
    'delete_tarefa',
    'check_in',
    'check_out',
    'list_ponto',
    'editar_ponto',
    'delete_ponto',
    'check_in_reuniao',
    'add_topico',
    'check_out_reuniao',
    'list_reuniao',
    'delete_reuniao',
    'gerar_relatorio',
]

intents = discord.Intents.default()
intents.message_content = True
intents.members = True
bot = commands.Bot(command_prefix=">", intents=intents)

bot.remove_command('help')

@bot.event
async def on_ready():
    print(f"Connected sucessfully as {bot.user}")
    await init_db()
    if not check_reminders.is_running():
        check_reminders.start()


@bot.command(help="Mostra esta mensagem de ajuda com todos os comandos dispon√≠veis.")
async def ajuda(ctx):
    """
    Mostra esta mensagem de ajuda com todos os comandos dispon√≠veis.
    A ordem de exibi√ß√£o √© definida na lista COMMAND_ORDER.
    """
    embed = discord.Embed(
        title="ü§ñ Comandos do Bot de Gerenciamento",
        description="Aqui est√£o todos os comandos que voc√™ pode usar:",
        color=discord.Color.green()
    )

    for command_name in COMMAND_ORDER:
        command = bot.get_command(command_name)
        if command and not command.hidden:
            embed.add_field(
                name=f"`>{command.name}`",
                value=f"{command.help}",
                inline=False
            )
    
    await ctx.send(embed=embed)

async def generate_pdf_report(guild_id, report_type="todos"):
    """
    Gera um relat√≥rio PDF com os dados do servidor
    report_type: "tarefas", "ponto", "reunioes", ou "todos"
    """
    filename = f"relatorio_{guild_id}_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
    doc = SimpleDocTemplate(filename, pagesize=A4)
    elements = []
    
    # Estilos
    styles = getSampleStyleSheet()
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=16,
        spaceAfter=30,
        alignment=1
    )
    
    title_text = f"Relat√≥rio #{guild_id} de Entrada - {datetime.datetime.now().strftime('%d/%m/%Y %H:%M')}"
    elements.append(Paragraph(title_text, title_style))
    elements.append(Spacer(1, 20))
    
    # Se√ß√£o de Tarefas
    if report_type in ["tarefas", "todos"]:
        # Agora usando a fun√ß√£o de banco de dados
        tasks = await get_tasks(guild_id)
        if tasks:
            elements.append(Paragraph("TAREFAS", styles['Heading2']))
            elements.append(Spacer(1, 10))
            
            task_data = [["ID", "T√≠tulo", "Respons√°vel", "Vencimento", "Status"]]
            for task in tasks:
                task_id, _, title, assigned_to, _, _, due_date_str, status = task
                due_dt = datetime.datetime.fromisoformat(due_date_str).astimezone(BR_TZ)
                due_date_formatted = due_dt.strftime('%d/%m/%Y %H:%M')
                task_data.append([str(task_id), title, assigned_to, due_date_formatted, status])
            
            task_table = Table(task_data, colWidths=[0.5*inch, 2*inch, 1.5*inch, 1.2*inch, 1*inch])
            task_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 10),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('FONTSIZE', (0, 1), (-1, -1), 8),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            elements.append(task_table)
            elements.append(Spacer(1, 20))
        else:
            elements.append(Paragraph("Nenhuma tarefa encontrada.", styles['Normal']))
            elements.append(Spacer(1, 10))
    
    # Se√ß√£o de Registros de Ponto
    if report_type in ["ponto", "todos"]:
        # Agora usando a fun√ß√£o de banco de dados
        entries = await get_clockpoint_entries(guild_id)
        if entries:
            elements.append(Paragraph("REGISTROS DE PONTO", styles['Heading2']))
            elements.append(Spacer(1, 10))
            
            ponto_data = [["ID", "Usu√°rio", "Entrada", "Sa√≠da", "Dura√ß√£o"]]
            for entry in entries:
                entry_id, user_id, check_in_str, check_out_str = entry
                
                try:
                    user = await bot.fetch_user(int(user_id))
                    user_name = user.display_name if user else f"ID: {user_id}"
                except:
                    user_name = f"ID: {user_id}"
                
                check_in_dt = datetime.datetime.fromisoformat(check_in_str).astimezone(BR_TZ)
                check_in_formatted = check_in_dt.strftime('%d/%m/%Y %H:%M')
                
                if check_out_str:
                    check_out_dt = datetime.datetime.fromisoformat(check_out_str).astimezone(BR_TZ)
                    check_out_formatted = check_out_dt.strftime('%d/%m/%Y %H:%M')
                    duration = check_out_dt - check_in_dt
                    hours, remainder = divmod(duration.total_seconds(), 3600)
                    minutes, _ = divmod(remainder, 60)
                    duration_str = f"{int(hours)}h {int(minutes)}m"
                else:
                    check_out_formatted = "Em andamento"
                    duration_str = "Em andamento"
                
                ponto_data.append([str(entry_id), user_name, check_in_formatted, check_out_formatted, duration_str])
            
            ponto_table = Table(ponto_data, colWidths=[0.5*inch, 1.5*inch, 1.5*inch, 1.5*inch, 1*inch])
            ponto_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 10),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('FONTSIZE', (0, 1), (-1, -1), 8),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            elements.append(ponto_table)
            elements.append(Spacer(1, 20))
        else:
            elements.append(Paragraph("Nenhum registro de ponto encontrado.", styles['Normal']))
            elements.append(Spacer(1, 10))
    
    # Se√ß√£o de Reuni√µes
    if report_type in ["reunioes", "todos"]:
        # Agora usando a fun√ß√£o de banco de dados
        meetings = await get_all_meetings(guild_id)
        if meetings:
            elements.append(Paragraph("REUNI√ïES", styles['Heading2']))
            elements.append(Spacer(1, 10))
            
            meeting_data = [["ID", "In√≠cio", "Dura√ß√£o", "Participantes", "T√≥picos"]]
            for meeting in meetings:
                meeting_id, participants_str, topics, check_in_time_str, check_out_time_str = meeting
                
                check_in_time = datetime.datetime.fromisoformat(check_in_time_str).astimezone(BR_TZ)
                check_in_formatted = check_in_time.strftime('%d/%m/%Y %H:%M')
                
                if check_out_time_str:
                    check_out_time = datetime.datetime.fromisoformat(check_out_time_str).astimezone(BR_TZ)
                    duration = check_out_time - check_in_time
                    hours, remainder = divmod(duration.total_seconds(), 3600)
                    minutes, seconds = divmod(remainder, 60)
                    duration_str = f"{int(hours)}h {int(minutes)}m"
                else:
                    duration_str = "Em andamento"
                
                # 1. Converte a string de IDs em uma lista
                participants_ids = participants_str.split(',')
                participants_display = []
                
                # 2. Itera sobre os IDs e busca o nome de cada participante
                for user_id in participants_ids:
                    try:
                        user = await bot.fetch_user(int(user_id))
                        participants_display.append(user.display_name if user else f"ID: {user_id}")
                    except (discord.NotFound, ValueError):
                        participants_display.append(f"ID: {user_id}")
                
                # 3. Junta os nomes dos participantes em uma √∫nica string
                participants_names_str = ", ".join(participants_display)
                
                topics_display = topics[:50] + "..." if len(topics) > 50 else topics
                
                meeting_data.append([str(meeting_id), check_in_formatted, duration_str, participants_names_str, topics_display])
            
            meeting_table = Table(meeting_data, colWidths=[0.5*inch, 1.2*inch, 1*inch, 1.2*inch, 2*inch])
            meeting_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 10),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('FONTSIZE', (0, 1), (-1, -1), 8),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            elements.append(meeting_table)
        else:
            elements.append(Paragraph("Nenhuma reuni√£o encontrada.", styles['Normal']))
    
    doc.build(elements)
    return filename


@bot.command(help="Adiciona uma nova tarefa por cargo ou por usu√°rio, define a data de t√©rmino e o tempo de intervalo entre lembretes. Ex: >add_tarefa 'Exemplo' | usuario | @usuario | 15/10/2025 23:59 | 1 dia ou >add_tarefa 'Exemplo' | cargo | @cargo | 15/10/2025 23:59 | 1 dia") 
async def add_tarefa(ctx, *, args):
    """
    Adiciona uma nova tarefa.
    T√çTULO | TIPO | @ | DATA DE T√âRMINO | INTERVALO DE LEMBRETES
    """
    try:
        guild_id = str(ctx.guild.id)
        things = [p.strip() for p in args.split("|")]

        if len(things) < 5:
            await ctx.send("‚ö†Ô∏è Formato inv√°lido. Use:\n`>add_tarefa t√≠tulo | tipo | respons√°vel | data fim | intervalo do lembrete`")
            return

        title, tp, destiny, due_date, reminder_interval = things
        
        # Data de in√≠cio √© sempre o momento atual
        start_dt = datetime.datetime.now(BR_TZ)
        start_dt_str = start_dt.isoformat()
        
        try:
            due_dt = BR_TZ.localize(datetime.datetime.strptime(due_date, "%d/%m/%Y %H:%M"))
            if due_dt <= start_dt:
                await ctx.send("‚ùå Data de t√©rmino deve ser depois da data atual.")
                return
        except ValueError:
            await ctx.send("‚ùå Data de t√©rmino inv√°lida. Use DD/MM/AAAA HH:MM.")
            return
        
        frequency_in_seconds = None
        
        match = re.search(r'(\d+)\s*(semanas?|meses?|dias?|horas?|minutos?)', reminder_interval, re.IGNORECASE)

        if match:
            number = int(match.group(1))
            text_unit = match.group(2).lower()
            
            if text_unit in TIME_UNITS:
                frequency_in_seconds = number * TIME_UNITS[text_unit]
            else:
                await ctx.send("‚ùå Unidade de tempo inv√°lida. Use 'semana(s)', 'mes(es)', 'dia(s)', 'hora(s) ou minuto(s)'.")
                return
        else:
            await ctx.send("‚ùå Formato de intervalo inv√°lido. Use, por exemplo: `2 semanas`, `3 dias`, `1 mes`, `12 horas` ou `3 minutos`.")
            return

        name_destiny = None
        if tp.lower() == "usuario":
            try:
                destiny_member = await commands.MemberConverter().convert(ctx, destiny)
                name_destiny = destiny_member.display_name
            except commands.MemberNotFound:
                await ctx.send(f"‚ùå Usu√°rio '{destiny}' n√£o encontrado no servidor.")
                return
        elif tp.lower() == "cargo":
            try:
                destiny_role = await commands.RoleConverter().convert(ctx, destiny)
                name_destiny = f"@{destiny_role.name}"
            except commands.RoleNotFound:
                await ctx.send(f"‚ùå Cargo '{destiny}' n√£o encontrado no servidor.")
                return
        else:
            await ctx.send("‚ùå Voc√™ precisa colocar o tipo da atribui√ß√£o. Use 'usuario' ou 'cargo'.")
            return
        
        due_dt_str = due_dt.isoformat()
        
        await add_task(guild_id, title, name_destiny, str(frequency_in_seconds), start_dt_str, due_dt_str, "A Fazer")
        
        await ctx.send(f"‚úÖ Tarefa **'{title}'** criada com sucesso e atribu√≠da a {name_destiny}.\n‚è∞ **Data de in√≠cio:** {start_dt.strftime('%d/%m/%Y %H:%M')}\n‚è∞ **Data de t√©rmino:** {due_dt.strftime('%d/%m/%Y %H:%M')}")
        
    except Exception as e:
        await ctx.send(f"‚ùå Erro ao criar a tarefa: {e}")

@bot.command(help="Listar todas as tarefas, ou por cargo, ou por usu√°rio. Ex: >list_tarefas ou >list_tarefas @usuario ou >list_tarefas @cargo ")
async def list_tarefas(ctx: commands.Context, *, args=None):
    """
    Comando para listar todas as tarefas ou filtrar por usu√°rio/cargo.
    Exemplo de uso:
    - >list_tarefas (Lista todas as tarefas)
    - >list_tarefas @nome_do_cargo (Lista tarefas de um cargo)
    - >list_tarefas nome_do_usuario (Lista tarefas de um usu√°rio)
    """
    try:
        guild_id = str(ctx.guild.id)
        tasks_list = []
        filter_name = None

        if args:
            try:
                # Tenta converter o argumento para um cargo
                role = await commands.RoleConverter().convert(ctx, args)
                filter_name = f"@{role.name}"
            except commands.RoleNotFound:
                try:
                    # Se falhar, tenta converter para um membro
                    member = await commands.MemberConverter().convert(ctx, args)
                    filter_name = member.display_name
                except commands.MemberNotFound:
                    # Se tamb√©m falhar, exibe uma mensagem de erro
                    await ctx.send(f"‚ùå N√£o foi poss√≠vel encontrar um usu√°rio ou cargo com o nome '{args}'.")
                    return
        
        if filter_name:
            tasks_list = await get_tasks_filtered(guild_id, filter_name)
            title = f"Tarefas para {filter_name}"
        else:
            tasks_list = await get_tasks(guild_id)
            title = "Todas as Tarefas"
        
        if not tasks_list:
            await ctx.send(f"N√£o h√° tarefas para exibir.")
            return

        embed = discord.Embed(
            title=title,
            color=discord.Color.blue()
        )
        
        for task in tasks_list:
            # A corre√ß√£o do erro est√° aqui: agora, esperamos 8 valores para
            # desempacotar, ignorando os valores que n√£o s√£o necess√°rios
            # para o embed (como o 'guild_id', o 'interval' e o 'start_date').
            try:
                task_id, _, task_title, assigned_to, _, _, due_date_str, status = task
            except ValueError as e:
                print(f"Erro ao desempacotar a tarefa: {e}. Conte√∫do: {task}")
                continue

            due_dt = datetime.datetime.fromisoformat(due_date_str).astimezone(BR_TZ)
            due_date_formatted = due_dt.strftime('%d/%m/%Y %H:%M')
            
            embed.add_field(
                name=f"üìù {task_title} (ID: {task_id})",
                value=f"**Respons√°vel:** {assigned_to}\n**Vencimento:** {due_date_formatted}\n**Status:** {status}",
                inline=False
            )
            
        await ctx.send(embed=embed)

    except Exception as e:
        print(f"‚ùå Ocorreu um erro ao listar as tarefas: {e}")
        await ctx.send(f"‚ùå Ocorreu um erro ao listar as tarefas: {e}")


@bot.command(help="Atualiza o status da tarefa pelo id e pela atribui√ß√£o. Ex: >update_status id @ A Fazer ou >update_status id @ Em Andamento ou >update_status id @ Conlu√≠da")
async def update_status(ctx, task_id: int, destiny: str, *, status: str):
    """
    Comando para atualizar o status de uma tarefa com base no ID e no respons√°vel.
    Status v√°lidos: "A Fazer", "Em Andamento", "Conclu√≠da".
    Exemplo de uso: >update_status 1 @Cargo Conclu√≠da
    """
    valid_statuses = ["A Fazer", "Em Andamento", "Conclu√≠da"]
    guild_id = str(ctx.guild.id)
    
    if status not in valid_statuses:
        await ctx.send(f"‚ùå Status inv√°lido. Use um dos seguintes: {', '.join(valid_statuses)}")
        return

    name_destiny = None
    try:
        role = await commands.RoleConverter().convert(ctx, destiny)
        name_destiny = f"@{role.name}"
    except commands.RoleNotFound:
        try:
            member = await commands.MemberConverter().convert(ctx, destiny)
            name_destiny = member.display_name
        except commands.MemberNotFound:
            await ctx.send(f"‚ùå N√£o foi poss√≠vel encontrar um usu√°rio ou cargo com o nome '{destiny}'.")
            return
            
    if name_destiny:
        try:
            success = await update_task_status(guild_id, task_id, name_destiny, status)
            if success:
                await ctx.send(f"‚úÖ O status da tarefa com ID **{task_id}** (atribu√≠da a {name_destiny}) foi atualizado para **{status}**.")
            else:
                await ctx.send(f"‚ùå N√£o foi poss√≠vel encontrar a tarefa com ID **{task_id}** atribu√≠da a {name_destiny}.")
        except Exception as e:
            await ctx.send(f"‚ùå Ocorreu um erro ao atualizar o status da tarefa: {e}")

@bot.command(help="Administrador do servidor deleta tarefa por id. Ex: >deleta_tarefa id")
@commands.has_permissions(administrator=True)
async def delete_tarefa(ctx, task_id: int):
    """
    Comando para excluir uma tarefa pelo ID. Apenas para administradores.
    Exemplo de uso: >delete_tarefa 1
    """
    try:
        guild_id = str(ctx.guild.id)
        success = await delete_task(guild_id, task_id)
        if success:
            await ctx.send(f"‚úÖ Tarefa com ID **{task_id}** exclu√≠da com sucesso.")
        else:
            await ctx.send(f"‚ùå N√£o foi poss√≠vel encontrar a tarefa com ID **{task_id}**.")
    except Exception as e:
        await ctx.send(f"‚ùå Ocorreu um erro ao excluir a tarefa: {e}")

@bot.command(help="Come√ßa a contagem do rel√≥gio de ponto. Ex: >check_in")
async def check_in(ctx):
    """
    Comando para registrar o in√≠cio do expediente.
    Exemplo de uso: >check_in
    """
    guild_id = str(ctx.guild.id)
    user_id = str(ctx.author.id)
    now = datetime.datetime.now(BR_TZ)
    
    if await is_user_checked_in(guild_id, user_id):
        await ctx.send("‚è∞ Voc√™ j√° est√° com um check-in ativo.")
        return

    try:
        await add_check_in(guild_id, user_id, now.isoformat())
        await ctx.send(f"‚úÖ **Check-in** registrado com sucesso em: **{now.strftime('%H:%M:%S')}**.")
    except Exception as e:
        await ctx.send(f"‚ùå Ocorreu um erro ao registrar the check-in: {e}")

@bot.command(help="Para a contagem do rel√≥gio de ponto. Ex: >check_out")
async def check_out(ctx):
    """
    Comando para registrar o fim do expediente.
    Exemplo de uso: >check_out
    """
    guild_id = str(ctx.guild.id)
    user_id = str(ctx.author.id)
    now = datetime.datetime.now(BR_TZ)
    
    if not await is_user_checked_in(guild_id, user_id):
        await ctx.send("‚ùå Voc√™ n√£o tem um check-in ativo para registrar o check-out.")
        return
        
    try:
        await add_check_out(guild_id, user_id, now.isoformat())
        await ctx.send(f"‚úÖ **Check-out** registrado com sucesso em: **{now.strftime('%H:%M:%S')}**.")
    except Exception as e:
        await ctx.send(f"‚ùå Ocorreu um erro ao registrar o check-out: {e}")

@bot.command(help="Lista todos os pontos ou por usu√°rio. Ex: >list_ponto ou >list_ponto @usuario")
async def list_ponto(ctx, member: discord.Member = None):
    """
    Comando para listar os registros de ponto.
    Exemplo de uso:
    - >list_ponto
    - >list_ponto @usuario
    """
    try:
        guild_id = str(ctx.guild.id)
        entries = []
        if member:
            entries = await get_clockpoint_entries_by_user(guild_id, str(member.id))
            title = f"Registros de Ponto para {member.display_name}"
        else:
            entries = await get_clockpoint_entries(guild_id)
            title = "Todos os Registros de Ponto"

        if not entries:
            await ctx.send(f"N√£o h√° registros de ponto para exibir.")
            return

        embed = discord.Embed(
            title=title,
            color=discord.Color.gold()
        )

        for entry_id, user_id, check_in_str, check_out_str in entries:
            user = await bot.fetch_user(int(user_id))
            user_name = user.display_name if user else "Usu√°rio Desconhecido"

            check_in_dt = datetime.datetime.fromisoformat(check_in_str).astimezone(BR_TZ)
            check_out_dt = None
            duration_str = "Em andamento"

            if check_out_str:
                check_out_dt = datetime.datetime.fromisoformat(check_out_str).astimezone(BR_TZ)
                duration = check_out_dt - check_in_dt
                hours, remainder = divmod(duration.total_seconds(), 3600)
                minutes, _ = divmod(remainder, 60)
                duration_str = f"{int(hours)}h {int(minutes)}m"

            embed.add_field(
                name=f"üë§ {user_name} (ID do Ponto: {entry_id})",
                value=f"**Entrada:** {check_in_dt.strftime('%d/%m/%Y %H:%M')}\n**Sa√≠da:** {check_out_dt.strftime('%d/%m/%Y %H:%M') if check_out_dt else 'N/A'}\n**Dura√ß√£o:** {duration_str}",
                inline=False
            )

        await ctx.send(embed=embed)
    except Exception as e:
        await ctx.send(f"‚ùå Ocorreu um erro ao listar os registros: {e}")

@bot.command(help="Edita o check in ou check out pelo id. Ex: >editar_ponto check_in id data e horario ou >editar_ponto checkout id data e horario")
async def editar_ponto(ctx, entry_id: int, tipo_registro: str, *, novo_horario: str):
    """
    Permite que o usu√°rio edite o seu pr√≥prio registro de ponto.
    Exemplo de uso: >editar_ponto 1 check_in 20/09/2025 09:00
    """
    try:
        guild_id = str(ctx.guild.id)
        entry = await get_clockpoint_entry_by_id(guild_id, entry_id)

        if not entry:
            await ctx.send(f"‚ùå Registro de ponto com ID **{entry_id}** n√£o encontrado.")
            return

        if str(entry[1]) != str(ctx.author.id):
            await ctx.send("‚ùå Voc√™ s√≥ pode editar os seus pr√≥prios registros de ponto.")
            return

        try:
            new_dt = BR_TZ.localize(datetime.datetime.strptime(novo_horario, "%d/%m/%Y %H:%M"))
            new_dt_iso = new_dt.isoformat()
        except ValueError:
            await ctx.send("‚ùå Formato de data e hora inv√°lido. Use `DD/MM/AAAA HH:MM`.")
            return

        old_check_in_dt = datetime.datetime.fromisoformat(entry[2]).astimezone(BR_TZ)
        old_check_out_str = entry[3]
        old_check_out_dt = datetime.datetime.fromisoformat(old_check_out_str).astimezone(BR_TZ) if old_check_out_str else None

        tipo_registro = tipo_registro.lower()
        if tipo_registro == "check_in":
            if old_check_out_dt and new_dt > old_check_out_dt:
                await ctx.send("‚ùå O novo hor√°rio de check-in n√£o pode ser depois do check-out existente.")
                return
            await update_check_in_time(guild_id, entry_id, new_dt_iso)
            await ctx.send(f"‚úÖ O check-in do registro **{entry_id}** foi atualizado para **{new_dt.strftime('%d/%m/%Y %H:%M')}**.")
        elif tipo_registro == "check_out":
            if new_dt < old_check_in_dt:
                await ctx.send("‚ùå O novo hor√°rio de check-out n√£o pode ser antes do check-in existente.")
                return
            await update_check_out_time(guild_id, entry_id, new_dt_iso)
            await ctx.send(f"‚úÖ O check-out do registro **{entry_id}** foi atualizado para **{new_dt.strftime('%d/%m/%Y %H:%M')}**.")
        else:
            await ctx.send("‚ùå Tipo de registro inv√°lido. Use 'check_in' ou 'check_out'.")
    except Exception as e:
        await ctx.send(f"‚ùå Ocorreu um erro ao editar o registro de ponto: {e}")

@commands.has_permissions(administrator=True)
@bot.command(help="Administrador do servidor deleta o ponto por id. Ex: >delete_ponto 15.")
async def delete_ponto(ctx, point_id: int):
    """
    Deleta um registro de ponto pelo seu ID. Apenas administradores podem usar.
    Exemplo de uso: >delete_ponto 15
    """
    try:
        guild_id = str(ctx.guild.id)
        rows_deleted = await delete_clockpoint_by_id(guild_id, point_id)
        if rows_deleted > 0:
            await ctx.send(f"‚úÖ Registro de ponto com ID **{point_id}** deletado com sucesso.")
        else:
            await ctx.send(f"‚ö†Ô∏è Nenhum registro de ponto encontrado com o ID **{point_id}**.")
    except Exception as e:
        await ctx.send(f"‚ùå Ocorreu um erro ao deletar o registro: {e}")

@bot.command(help="Come√ßa a contagem do tempo de reuni√£o. Ex: >check_in_reuniao @Fulano @Ciclano @Beltrano")
async def check_in_reuniao(ctx, *members: discord.Member):
    """
    Comando para iniciar uma reuni√£o com outros membros.
    Exemplo de uso: >check_in_reuniao @utilizador1 @utilizador2
    """
    guild_id = str(ctx.guild.id)
    participants_list = list(members) + [ctx.author]
    participants_list = list(set(participants_list))
    
    participants_ids = ",".join([str(m.id) for m in participants_list])
    
    active_meeting = await get_active_meeting_by_user(guild_id, str(ctx.author.id))
    
    if active_meeting:
        await ctx.send("‚ùå Voc√™ j√° est√° em uma reuni√£o. Use `>check_out` para finalizar.")
        return
        
    try:
        await add_meeting_check_in(guild_id, participants_ids)
        participants_names = [m.display_name for m in participants_list]
        await ctx.send(f"‚úÖ Reuni√£o iniciada com os participantes: **{', '.join(participants_names)}**. Use `>add_topico` para adicionar t√≥picos.")
    except Exception as e:
        await ctx.send(f"‚ùå Ocorreu um erro ao iniciar a reuni√£o: {e}")

@bot.command(help="Quem est√° na reuni√£o pode adicionar t√≥picos que foram mencionados. Ex: >add_topico Planejamento")
async def add_topico(ctx, *, topics: str):
    """
    Adiciona t√≥picos √† sua reuni√£o ativa. Qualquer participante pode usar.
    Exemplo de uso: >add_topico t√≥pico 1, t√≥pico 2, t√≥pico 3
    """
    guild_id = str(ctx.guild.id)
    user_id = str(ctx.author.id)
    active_meeting = await get_active_meeting_by_user(guild_id, user_id)

    if not active_meeting:
        await ctx.send("‚ùå Voc√™ n√£o est√° em uma reuni√£o ativa. Use `>check_in_meet` para iniciar uma.")
        return
    
    meeting_id = active_meeting[0]
    
    try:
        await add_meeting_topic(guild_id, meeting_id, topics)
        await ctx.send(f"‚úÖ T√≥picos **`{topics}`** adicionados √† reuni√£o.")
    except Exception as e:
        await ctx.send(f"‚ùå Ocorreu um erro ao adicionar os t√≥picos: {e}")

@bot.command(help="Comando para finalizar a reuni√£o. Qualquer participante pode usar. Ex: >check_out_reuniao")
async def check_out_reuniao(ctx):
    """
    Comando para finalizar a reuni√£o atual. Qualquer participante pode usar.
    """
    guild_id = str(ctx.guild.id)
    user_id = str(ctx.author.id)
    active_meeting_data = await get_active_meeting_by_user(guild_id, user_id)
    
    if not active_meeting_data:
        await ctx.send("‚ùå Voc√™ n√£o est√° em uma reuni√£o ativa. Use `>check_in` para iniciar uma.")
        return
        
    meeting_id, participants_str, topics, check_in_time_str = active_meeting_data
    
    check_in_time = datetime.datetime.fromisoformat(check_in_time_str).astimezone(BR_TZ)
    now = datetime.datetime.now(BR_TZ)
    duration = now - check_in_time
    hours, remainder = divmod(duration.total_seconds(), 3600)
    minutes, seconds = divmod(remainder, 60)
    duration_str = f"{int(hours)}h {int(minutes)}m {int(seconds)}s"

    participants_ids = participants_str.split(',')
    participants_mentions = [f"<@{uid}>" for uid in participants_ids]
    
    try:
        await update_meeting_check_out(guild_id, meeting_id)
        
        await ctx.send(
            f"‚úÖ **{ctx.author.display_name}** finalizou a reuni√£o.\n"
            f"**In√≠cio:** {check_in_time.strftime('%H:%M:%S')}\n"
            f"**Dura√ß√£o:** {duration_str}\n"
            f"**Participantes:** {', '.join(participants_mentions)}\n"
            f"**T√≥picos:** `{topics}`"
        )
    except Exception as e:
        await ctx.send(f"‚ùå Ocorreu um erro ao finalizar a reuni√£o: {e}")

@bot.command(help="Comando para listar todas as reuni√µes ou por usu√°rio. Ex: >list_reuniao ou >list_reuniao @usuario")
async def list_reuniao(ctx, member: discord.Member = None):
    """
    Lista todas as reuni√µes ou as reuni√µes de um utilizador espec√≠fico.
    Exemplos de uso:
    >list_reuniao        (lista todas as reuni√µes)
    >list_reuniao @usuario  (lista as reuni√µes de um utilizador espec√≠fico)
    """
    try:
        guild_id = str(ctx.guild.id)
        if member:
            meetings = await get_meetings_by_user(guild_id, str(member.id))
            if not meetings:
                await ctx.send(f"‚ö†Ô∏è Nenhuma reuni√£o encontrada para o utilizador **{member.display_name}**.")
                return
            title_text = f"Hist√≥rico de Reuni√µes de {member.display_name}"
        else:
            meetings = await get_all_meetings(guild_id)
            if not meetings:
                await ctx.send("‚ö†Ô∏è Nenhuma reuni√£o encontrada no hist√≥rico.")
                return
            title_text = "Hist√≥rico de Reuni√µes"

        embed = discord.Embed(title=title_text, color=discord.Color.blue())
        for meeting in meetings:
            meeting_id, participants_str, topics, check_in_time_str, check_out_time_str = meeting
            
            participants_ids = participants_str.split(',')
            participants_names = []
            for uid in participants_ids:
                m = ctx.guild.get_member(int(uid))
                participants_names.append(m.display_name if m else f"ID: {uid}")
            
            check_in_time = datetime.datetime.fromisoformat(check_in_time_str).astimezone(BR_TZ)
            duration_str = "Em andamento"
            if check_out_time_str:
                check_out_time = datetime.datetime.fromisoformat(check_out_time_str).astimezone(BR_TZ)
                duration = check_out_time - check_in_time
                hours, remainder = divmod(duration.total_seconds(), 3600)
                minutes, seconds = divmod(remainder, 60)
                duration_str = f"{int(hours)}h {int(minutes)}m {int(seconds)}s"

            embed.add_field(
                name=f"Reuni√£o #{meeting_id}",
                value=(
                    f"**In√≠cio:** {check_in_time.strftime('%d/%m/%Y %H:%M:%S')}\n"
                    f"**Dura√ß√£o:** {duration_str}\n"
                    f"**Participantes:** {', '.join(participants_names)}\n"
                    f"**T√≥picos:** {topics or 'Nenhum'}"
                ),
                inline=False
            )
        await ctx.send(embed=embed)
    except Exception as e:
        await ctx.send(f"‚ùå Ocorreu um erro ao listar as reuni√µes: {e}")

@commands.has_permissions(administrator=True)
@bot.command(help="Administradores do servidor podem deletar uma reuni√£o por id. Ex: >delete_reuni√£o 15")
async def delete_reuniao(ctx, meeting_id: int):
    """
    Deleta uma reuni√£o pelo seu ID. Apenas administradores podem usar.
    Exemplo de uso: >delete_meeting 15
    """
    try:
        guild_id = str(ctx.guild.id)
        rows_deleted = await delete_meeting_by_id(guild_id, meeting_id)
        if rows_deleted > 0:
            await ctx.send(f"‚úÖ Reuni√£o com ID **{meeting_id}** deletada com sucesso.")
        else:
            await ctx.send(f"‚ö†Ô∏è Nenhuma reuni√£o encontrada com o ID **{meeting_id}**.")
    except Exception as e:
        await ctx.send(f"‚ùå Ocorreu um erro ao deletar a reuni√£o: {e}")

@bot.command(help="Gera um relat√≥rio em PDF com tarefas, pontos e reuni√µes. Ex: >gerar_relatorio ou >gerar_relatorio tarefas")
async def gerar_relatorio(ctx, report_type: str = "todos"):
    """
    Gera um relat√≥rio PDF com os dados do servidor
    Op√ß√µes: tarefas, ponto, reunioes, todos
    """
    valid_types = ["tarefas", "ponto", "reunioes", "todos"]
    
    if report_type.lower() not in valid_types:
        await ctx.send("‚ùå Tipo de relat√≥rio inv√°lido. Use: `tarefas`, `ponto`, `reunioes` ou `todos`")
        return
    
    try:
        guild_id = str(ctx.guild.id)
        await ctx.send("üìä Gerando relat√≥rio PDF...")
        
        # Gerar o PDF
        filename = await generate_pdf_report(guild_id, report_type.lower())
        
        # Enviar o arquivo
        with open(filename, 'rb') as f:
            await ctx.send(file=discord.File(f, filename))
        
        # Limpar o arquivo tempor√°rio
        os.remove(filename)
        await ctx.send("‚úÖ Relat√≥rio gerado com sucesso!")
        
    except Exception as e:
        await ctx.send(f"‚ùå Erro ao gerar relat√≥rio: {e}")
        print(f"Erro ao gerar PDF: {e}")

@tasks.loop(minutes=1)
async def check_reminders():
    print("Verificando lembretes...")
    now = datetime.datetime.now(BR_TZ)
    
    try:
        for guild in bot.guilds:
            guild_id = str(guild.id)
            tasks = await get_tasks(guild_id)
            
            for task in tasks:
                try:
                    task_id, task_guild_id, title, assigned_to, interval_str, start_date_str, due_date_str, status = task
                except ValueError as e:
                    print(f"Erro ao desempacotar tarefa: {e}. Conte√∫do da tarefa: {task}")
                    continue

                start_dt = datetime.datetime.fromisoformat(start_date_str).astimezone(BR_TZ)
                due_dt = datetime.datetime.fromisoformat(due_date_str).astimezone(BR_TZ)
                
                if status == "Em Andamento":
                    reminder_interval_seconds = int(interval_str)
                    time_since_last_reminder = now - start_dt


                    if time_since_last_reminder.total_seconds() >= reminder_interval_seconds:
                        
                        destiny = None
                        user_found = discord.utils.get(guild.members, display_name=assigned_to)
                        if user_found:
                            destiny = user_found
                        else:
                            role_name = assigned_to.lstrip('@')
                            role_found = discord.utils.get(guild.roles, name=role_name)
                            if role_found:
                                destiny = role_found

                        if destiny:
                            is_overdue = now > due_dt
                            
                            if is_overdue:
                                reminder_message = (
                                    f"üö® **TAREFA ATRASADA!** üö®\n"
                                    f"A tarefa **'{title}'** venceu em {due_dt.strftime('%d/%m/%Y %H:%M')}.\n"
                                    f"**Respons√°vel:** {assigned_to}\n"
                                    f"Este √© um lembrete peri√≥dico de atraso."
                                )
                            else:
                                reminder_message = (
                                    f"üîî **Lembrete de Tarefa** üîî\n"
                                    f"**T√≠tulo:** {title}\n"
                                    f"**Vencimento:** {due_dt.strftime('%d/%m/%Y %H:%M')}\n"
                                    f"**Respons√°vel:** {assigned_to}"
                                )
                            
                            target_channel = next((c for c in guild.text_channels if c.permissions_for(guild.me).send_messages), None)
                            if target_channel:
                                await target_channel.send(f"{destiny.mention}\n{reminder_message}")

                            await update_task_start_date(guild_id, task_id, now.isoformat())

    except Exception as e:
        print(f"‚ùå Erro na tarefa de lembretes: {e}")


bot.run(TOKEN)